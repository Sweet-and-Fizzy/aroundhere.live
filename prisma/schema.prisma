// Local Music Listings Service - Database Schema
// Using PostgreSQL with PostGIS for geo queries

generator client {
  provider        = "prisma-client-js"
  output          = "../node_modules/.prisma/client"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  extensions = [postgis, fuzzystrmatch, postgis_tiger_geocoder, postgis_topology, vector]
}

// Geographic regions - auto-generated from venue clustering
model Region {
  id            String   @id @default(cuid())
  name          String   @unique
  slug          String   @unique
  timezone      String   @default("America/New_York")
  // Centroid calculated from clustered venues
  centroidLat   Float?
  centroidLng   Float?
  defaultRadius Int      @default(25) // miles
  isActive      Boolean  @default(true)
  isAutoGenerated Boolean @default(false) // true if created by clustering algorithm
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  venues Venue[]
  events Event[]
  users  User[]

  @@map("regions")
}

// Music venues
model Venue {
  id         String     @id @default(cuid())
  regionId   String
  name       String
  slug       String
  address    String?
  city       String?
  state      String?
  postalCode String?
  latitude   Float?
  longitude  Float?
  // PostGIS point will be managed via raw SQL/migrations
  capacity   Int?
  venueType  VenueType  @default(OTHER)
  website    String?
  phone      String?
  email      String?
  logoUrl    String?    // Venue logo for display when events lack images
  imageUrl   String?    // Hero/banner image for venue page
  description String?   // About the venue
  accessibilityInfo String? // Accessibility features (wheelchair access, parking, etc.)
  verified   Boolean    @default(false)
  isActive   Boolean    @default(true)
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  region Region  @relation(fields: [regionId], references: [id])
  events Event[]
  favoritedBy UserFavoriteVenue[]

  @@unique([regionId, slug])
  @@index([regionId])
  @@index([latitude, longitude])
  @@map("venues")
}

enum VenueType {
  BAR
  BREWERY
  CLUB
  THEATER
  CONCERT_HALL
  OUTDOOR
  CAFE
  RESTAURANT
  HOUSE_SHOW
  OTHER
}

// Artists and bands
model Artist {
  id            String   @id @default(cuid())
  name          String
  slug          String   @unique
  genres        String[] // array of genre slugs
  description   String?
  website       String?
  socialLinks   Json?    // { instagram, facebook, bandcamp, spotify, etc. }
  musicbrainzId String?
  isLocal       Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Spotify integration
  spotifyId              String?              // Spotify artist ID
  spotifyName            String?              // Name as it appears on Spotify (may differ)
  spotifyMatchConfidence Float?               // 0-1 confidence score from name matching
  spotifyMatchStatus     SpotifyMatchStatus   @default(PENDING)
  spotifyPopularTracks   Json?                // [{trackId, name, uri, durationMs}]
  spotifyTracksUpdatedAt DateTime?            // When popular tracks were last fetched
  spotifyGenres          String[]             // Spotify's genre taxonomy
  spotifyFetchedAt       DateTime?            // When Spotify data was last fetched

  // MusicBrainz integration (similar pattern to Spotify)
  musicbrainzMatchStatus     MusicBrainzMatchStatus @default(PENDING)
  musicbrainzMatchConfidence Float?               // 0-1 confidence score from name matching
  musicbrainzTags            String[]             // Community tags like ["melancholic", "political", "lo-fi"]
  musicbrainzDescription     String?              // Artist bio/description
  musicbrainzRelatedIds      String[]             // Related artist MusicBrainz IDs
  musicbrainzFetchedAt       DateTime?            // When MusicBrainz data was last fetched

  // Computed artist profile embedding (combines all sources)
  profileEmbedding          Unsupported("vector(1536)")?
  profileEmbeddingUpdatedAt DateTime?

  eventArtists          EventArtist[]
  spotifyPlaylistTracks SpotifyPlaylistTrack[]
  artistReviews         ArtistReview[]
  favoritedBy           UserFavoriteArtist[]

  @@index([name])
  @@index([spotifyMatchStatus])
  @@index([musicbrainzMatchStatus])
  @@map("artists")
}

// Events (shows, concerts)
model Event {
  id              String       @id @default(cuid())
  regionId        String
  venueId         String?
  title           String
  slug            String
  description     String?
  descriptionHtml String?      // Rich HTML description with images/videos/links
  imageUrl        String?      // Event/artist image from source
  startsAt        DateTime
  endsAt          DateTime?
  doorsAt         DateTime?
  coverCharge     String?      // "Free", "$10", "$10-15", "Donation"
  ageRestriction  AgeRestriction @default(ALL_AGES)
  ticketUrl       String?
  genres          String[]     // Genre/category tags from source (raw from scraper)

  // Classification fields (populated by AI classifier)
  isMusic           Boolean?       // true=music event, false=non-music, null=unclassified
  eventType         EventType?     // Classified event type
  canonicalGenres   String[]       // Normalized genre slugs from classifier
  summary           String?        // AI-generated concise summary for listing cards
  classifiedAt      DateTime?      // When classification was performed
  classificationConfidence Float?  // 0-1 confidence score from classifier
  classificationAttempts Int       @default(0) // Number of classification attempts (for retry tracking)

  sourceId        String?
  sourceUrl       String?
  sourceEventId   String?      // ID from the source for dedup
  confidenceScore Float        @default(1.0)
  reviewStatus    ReviewStatus @default(PENDING)
  reviewedBy      String?
  reviewedAt      DateTime?
  isCancelled     Boolean      @default(false)
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  // Vector embedding for similarity search (managed via raw SQL)
  embedding       Unsupported("vector(1536)")?

  region       Region        @relation(fields: [regionId], references: [id])
  venue        Venue?        @relation(fields: [venueId], references: [id])
  source       Source?       @relation(fields: [sourceId], references: [id]) // Canonical source
  eventArtists EventArtist[]
  eventSources EventSource[] // All sources that found this event
  spotifyPlaylistTracks SpotifyPlaylistTrack[]
  recommendationLogs    RecommendationLog[]

  @@unique([sourceId, sourceEventId])
  @@index([regionId, startsAt])
  @@index([venueId])
  @@index([reviewStatus])
  @@map("events")
}

enum AgeRestriction {
  ALL_AGES
  EIGHTEEN_PLUS
  TWENTY_ONE_PLUS
}

enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
  FLAGGED
}

enum EventType {
  MUSIC
  DJ
  OPEN_MIC
  COMEDY
  THEATER
  GAMES
  KARAOKE
  PRIVATE
  FILM
  SPOKEN_WORD
  DANCE
  MARKET
  WORKSHOP
  PARTY
  FITNESS
  DRAG
  OTHER
}

// Junction table for events and artists
model EventArtist {
  id        String    @id @default(cuid())
  eventId   String
  artistId  String
  order     Int       @default(1) // 1 = headliner, 2+ = support acts in billing order
  setTime   DateTime?

  event  Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  artist Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@unique([eventId, artistId])
  @@index([artistId])
  @@map("event_artists")
}

// Data sources (scrapers, APIs, manual)
model Source {
  id            String     @id @default(cuid())
  name          String     @unique
  slug          String     @unique
  type          SourceType
  category      SourceCategory @default(OTHER) // For dedup priority
  priority      Int        @default(50) // Lower = higher priority (venue=10, ticketing=20, band=30, etc.)
  trustScore    Float      @default(0.5) // 0-1
  website       String?
  parserVersion String?
  config        Json?      // scraper-specific config
  lastRunAt     DateTime?
  lastRunStatus String?
  nextRunAt     DateTime?
  runFrequency  Int        @default(86400) // seconds between runs
  consecutiveFailures Int  @default(0) // Track consecutive failures for notifications
  lastFailureAt DateTime?  // When the last failure occurred
  lastEventCount Int?       // Event count from last successful run (for failure detection)
  isActive      Boolean    @default(true)

  // Notification gating - pause notifications when duplicates detected
  notificationsPaused   Boolean   @default(false)
  notificationsPausedAt DateTime?
  notificationsPausedReason String?

  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  events          Event[]          // Events where this is the canonical source
  eventSources    EventSource[]    // All events this source has contributed to
  scraperVersions ScraperVersion[] // Version history for AI-generated scrapers

  @@map("sources")
}

enum SourceType {
  SCRAPER
  API
  MANUAL
  IMPORT
}

enum SourceCategory {
  VENUE      // Official venue website - highest priority
  TICKETING  // Ticketing platforms
  PROMOTER   // Promoter/booking agency sites
  ARTIST     // Band/artist websites
  AGGREGATOR // Other aggregators
  SOCIAL     // Social media
  OTHER      // Unknown/other
}

// Track all sources that mention an event (for dedup and data enrichment)
model EventSource {
  id           String   @id @default(cuid())
  eventId      String
  sourceId     String
  sourceUrl    String?  // URL where this source found the event
  sourceEventId String? // ID from this source
  scrapedAt    DateTime @default(now())
  rawData      Json?    // Original scraped data for reference

  event  Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  source Source @relation(fields: [sourceId], references: [id])

  @@unique([eventId, sourceId])
  @@index([sourceId])
  @@map("event_sources")
}

// Genre taxonomy (hierarchical)
model Genre {
  id        String   @id @default(cuid())
  name      String   @unique
  slug      String   @unique
  parentId  String?
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())

  parent   Genre?  @relation("GenreHierarchy", fields: [parentId], references: [id])
  children Genre[] @relation("GenreHierarchy")

  @@index([parentId])
  @@map("genres")
}

// Users (admin, liaisons)
model User {
  id            String   @id @default(cuid())
  email         String   @unique
  emailVerified Boolean  @default(false)
  displayName   String?
  role          UserRole @default(USER)
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // User's region (for filtering recommendations)
  regionId      String?
  region        Region?  @relation(fields: [regionId], references: [id])

  // Notification preferences
  emailNotifications      Boolean  @default(true)
  notificationFrequency   String   @default("daily") // "daily", "weekly", "none"
  notifyFavoriteArtists   Boolean  @default(true)
  lastNotificationSent    DateTime?

  // Weekly recommendations preferences
  interestDescription       String?   // Free-form "what are you interested in?" text
  interestEmbedding         Unsupported("vector(1536)")? // Embedding of interest description
  tasteProfileEmbedding     Unsupported("vector(1536)")? // Computed from favorite artists
  tasteProfileUpdatedAt     DateTime? // When taste profile was last computed
  enableRecommendations     Boolean   @default(true) // Weekly recommendations
  lastRecommendationSent    DateTime? // When last recommendation email was sent

  loginTokens         LoginToken[]
  favoriteArtists     UserFavoriteArtist[]
  favoriteVenues      UserFavoriteVenue[]
  favoriteGenres      UserFavoriteGenre[]
  favoriteEventTypes  UserFavoriteEventType[]
  recommendationLogs  RecommendationLog[]

  @@map("users")
}

// User's favorite artists
model UserFavoriteArtist {
  id        String   @id @default(cuid())
  userId    String
  artistId  String
  createdAt DateTime @default(now())

  user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
  artist Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@unique([userId, artistId])
  @@index([userId])
  @@index([artistId])
  @@map("user_favorite_artists")
}

// User's favorite venues
model UserFavoriteVenue {
  id        String   @id @default(cuid())
  userId    String
  venueId   String
  createdAt DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  venue Venue @relation(fields: [venueId], references: [id], onDelete: Cascade)

  @@unique([userId, venueId])
  @@index([userId])
  @@index([venueId])
  @@map("user_favorite_venues")
}

// User's favorite genres
model UserFavoriteGenre {
  id        String   @id @default(cuid())
  userId    String
  genre     String   // canonical genre slug (e.g., "jazz", "rock")
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, genre])
  @@index([userId])
  @@map("user_favorite_genres")
}

// User's favorite event types
model UserFavoriteEventType {
  id        String   @id @default(cuid())
  userId    String
  eventType String   // event type slug (e.g., "COMEDY", "DJ")
  createdAt DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, eventType])
  @@index([userId])
  @@map("user_favorite_event_types")
}

enum UserRole {
  ADMIN
  MODERATOR
  USER
}

enum SpotifyMatchStatus {
  PENDING         // Not yet searched on Spotify
  AUTO_MATCHED    // High confidence automatic match (>0.9)
  NEEDS_REVIEW    // Low confidence match, needs human verification
  VERIFIED        // Manually confirmed correct match
  NO_MATCH        // Confirmed not on Spotify or should be skipped
}

enum MusicBrainzMatchStatus {
  PENDING         // Not yet searched on MusicBrainz
  AUTO_MATCHED    // High confidence automatic match (>0.9)
  NEEDS_REVIEW    // Low confidence match, needs human verification
  VERIFIED        // Manually confirmed correct match
  NO_MATCH        // Confirmed not on MusicBrainz or should be skipped
}

// Login tokens for magic link authentication
model LoginToken {
  id        String   @id @default(cuid())
  token     String   @unique
  email     String
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([email])
  @@index([token])
  @@map("login_tokens")
}

// AI Agent Sessions for scraper generation
model AgentSession {
  id              String            @id @default(cuid())
  url             String            // Target venue URL
  sessionType     AgentSessionType  // VENUE_INFO or EVENT_SCRAPER
  status          AgentSessionStatus @default(IN_PROGRESS)
  llmProvider     String            // anthropic, openai, google, deepseek
  llmModel        String            // model identifier
  currentIteration Int             @default(0)
  maxIterations   Int              @default(5)

  // Results
  venueData       Json?            // Scraped venue information
  eventData       Json?            // Array of scraped events
  generatedCode   String?          // Final working scraper code
  completenessScore Float?         // 0-1 score of field coverage

  // Metadata
  errorMessage    String?
  thinking        Json?            // Array of thinking steps for display
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  completedAt     DateTime?

  // Relations
  venueId         String?          // Linked after approval
  sourceId        String?          // Linked after approval

  attempts        ScraperAttempt[]

  @@index([status])
  @@index([createdAt])
  @@map("agent_sessions")
}

enum AgentSessionType {
  VENUE_INFO      // First pass: scrape venue details
  EVENT_SCRAPER   // Second pass: generate event scraper
}

enum AgentSessionStatus {
  IN_PROGRESS
  SUCCESS
  FAILED
  APPROVED        // User approved and records created
  REJECTED        // User rejected
}

// Individual scraper generation attempts within a session
model ScraperAttempt {
  id              String        @id @default(cuid())
  sessionId       String
  attemptNumber   Int

  // Agent thinking
  reasoning       String?       // Why this approach
  planDescription String?       // What the agent plans to do

  // Input context - HTML the agent was working with
  // Structure: { listing: string, detailPages?: { url: string, html: string }[] }
  htmlSnapshots   Json?

  // Generated code
  generatedCode   String        // The scraper code generated
  codeHash        String?       // Hash to detect duplicate attempts

  // Execution results
  executionStatus String        // PENDING, RUNNING, SUCCESS, ERROR, TIMEOUT
  executionError  String?
  executionTime   Int?          // milliseconds
  scrapedData     Json?         // Results from execution

  // Evaluation
  fieldsFound     String[]      // Which fields were successfully extracted
  fieldsMissing   String[]      // Which required fields are missing
  completenessScore Float?      // 0-1 score

  createdAt       DateTime      @default(now())
  completedAt     DateTime?

  session         AgentSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, attemptNumber])
  @@index([sessionId])
  @@map("scraper_attempts")
}

// LLM Provider Configuration
model LLMConfig {
  id              String   @id @default(cuid())
  provider        String   @unique // anthropic, openai, google, deepseek
  apiKey          String   // Encrypted
  isEnabled       Boolean  @default(true)
  models          Json     // Available models for this provider
  defaultModel    String?  // Default model to use
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("llm_configs")
}

// Spotify playlist sync configuration
model SpotifyPlaylist {
  id           String    @id @default(cuid())
  playlistId   String    @unique  // Spotify playlist ID
  name         String              // Display name for admin UI
  description  String?             // Playlist description
  regionId     String?             // Optional: limit to specific region
  daysAhead    Int       @default(30)  // How many days ahead to include events
  syncEnabled  Boolean   @default(true)
  lastSyncedAt DateTime?
  lastSyncError String?            // Error message from last failed sync
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@map("spotify_playlists")
}

// Track which tracks are currently in each playlist (for efficient diffing)
model SpotifyPlaylistTrack {
  id           String   @id @default(cuid())
  playlistId   String   // References SpotifyPlaylist.playlistId
  trackUri     String   // Spotify track URI
  artistId     String   // Our artist ID
  eventId      String   // The event this track is for
  addedAt      DateTime @default(now())

  event  Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  artist Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@unique([playlistId, trackUri])
  @@index([playlistId])
  @@index([eventId])
  @@index([artistId])
  @@map("spotify_playlist_tracks")
}

// Spotify OAuth credentials (singleton - only one row)
model SpotifyAuth {
  id           String   @id @default("spotify_auth") // Fixed ID for singleton
  accessToken  String   // Current access token
  refreshToken String   // Refresh token for getting new access tokens
  expiresAt    DateTime // When the access token expires
  scope        String   // Granted scopes
  userId       String?  // Spotify user ID of the authorized account
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("spotify_auth")
}

// Review sources (local music blogs, newsletters)
model ReviewSource {
  id            String    @id @default(cuid())
  name          String    @unique // "Freakscene"
  slug          String    @unique // "freakscene"
  feedUrl       String    // Archive/feed URL to scrape
  type          String    @default("buttondown") // buttondown, rss, etc.
  lastFetchedAt DateTime?
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  reviews Review[]

  @@map("review_sources")
}

// Reviews/articles from local music writers
model Review {
  id          String    @id @default(cuid())
  sourceId    String
  url         String    @unique // Canonical URL of the review
  title       String
  excerpt     String?   // First paragraph or so for display
  publishedAt DateTime?
  fetchedAt   DateTime  @default(now())

  source        ReviewSource   @relation(fields: [sourceId], references: [id])
  artistReviews ArtistReview[]

  @@index([sourceId])
  @@index([publishedAt])
  @@map("reviews")
}

// Junction table linking reviews to featured artists
model ArtistReview {
  id        String   @id @default(cuid())
  artistId  String
  reviewId  String
  createdAt DateTime @default(now())

  artist Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)
  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  @@unique([artistId, reviewId])
  @@index([reviewId])
  @@map("artist_reviews")
}

// Recommendation logs for tracking sent recommendations
model RecommendationLog {
  id                  String   @id @default(cuid())
  userId              String
  eventId             String
  sentAt              DateTime @default(now())
  recommendationType  String   // FAVORITE_ARTIST, AI_WEEKEND_PICK, AI_COMING_UP
  confidenceScore     Float    // 0-1 confidence in the recommendation
  matchReason         String   // Human-readable explanation

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  event Event @relation(fields: [eventId], references: [id], onDelete: Cascade)

  @@index([userId, sentAt])
  @@index([eventId])
  @@map("recommendation_logs")
}

// Chat logs for AI assistant interactions
model ChatLog {
  id                 String   @id @default(cuid())
  sessionId          String   // Group conversations together
  timestamp          DateTime @default(now())
  ipAddress          String?  // For rate limiting by IP

  // Request
  userMessage        String
  conversationLength Int      // How many turns in

  // LLM Usage (cost tracking)
  inputTokens        Int
  outputTokens       Int
  estimatedCostUsd   Float    // Calculated from token counts
  llmCallsCount      Int      // 1 = direct answer, 2+ = tool use
  model              String

  // Tools
  toolsUsed          String[] // ["search_events", "get_venue_events"]
  toolInputs         Json?    // For debugging

  // Response
  responseText       String
  latencyMs          Int

  // Quality signals
  userRating         Int?     // 1-5 or thumbs up/down

  @@index([sessionId])
  @@index([timestamp])
  @@index([ipAddress, timestamp]) // For IP-based rate limiting
  @@map("chat_logs")
}

// Scraper version history for AI-generated scrapers
model ScraperVersion {
  id             String   @id @default(cuid())
  sourceId       String
  versionNumber  Int      // Auto-increment per source (1, 2, 3, ...)

  // Code and metadata
  code           String   // The actual scraper code
  codeHash       String   // SHA256 hash for deduplication
  description    String?  // User-provided change description

  // Origin tracking
  createdBy      String?  // User ID if manual edit
  createdFrom    ScraperVersionOrigin // How this version was created
  agentSessionId String?  // Link to AgentSession if AI-generated

  // Execution history
  lastTestedAt   DateTime?
  testResults    Json?    // { success, eventCount, errors, sampleEvents[], fieldsAnalysis }

  // Status
  isActive       Boolean  @default(false) // Only one version active per source
  createdAt      DateTime @default(now())
  updatedAt      DateTime @updatedAt

  source         Source   @relation(fields: [sourceId], references: [id], onDelete: Cascade)

  @@unique([sourceId, versionNumber])
  @@index([sourceId, isActive])
  @@index([sourceId, codeHash]) // For duplicate detection
  @@index([agentSessionId])
  @@map("scraper_versions")
}

enum ScraperVersionOrigin {
  AI_GENERATED  // Created by AI agent
  MANUAL_EDIT   // Manually edited by user
  ROLLBACK      // Rolled back to previous version
}
