// Local Music Listings Service - Database Schema
// Using PostgreSQL with PostGIS for geo queries

generator client {
  provider        = "prisma-client-js"
  output          = "../node_modules/.prisma/client"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  extensions = [postgis, fuzzystrmatch, postgis_tiger_geocoder, postgis_topology, vector]
}

// Geographic regions (cities, metros)
model Region {
  id            String   @id @default(cuid())
  name          String   @unique
  slug          String   @unique
  timezone      String   @default("America/New_York")
  // bounds stored as GeoJSON in a separate table or raw SQL for PostGIS
  defaultRadius Int      @default(25) // miles
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  venues Venue[]
  events Event[]

  @@map("regions")
}

// Music venues
model Venue {
  id         String     @id @default(cuid())
  regionId   String
  name       String
  slug       String
  address    String?
  city       String?
  state      String?
  postalCode String?
  latitude   Float?
  longitude  Float?
  // PostGIS point will be managed via raw SQL/migrations
  capacity   Int?
  venueType  VenueType  @default(OTHER)
  website    String?
  phone      String?
  logoUrl    String?    // Venue logo for display when events lack images
  imageUrl   String?    // Hero/banner image for venue page
  description String?   // About the venue
  verified   Boolean    @default(false)
  isActive   Boolean    @default(true)
  createdAt  DateTime   @default(now())
  updatedAt  DateTime   @updatedAt

  region Region  @relation(fields: [regionId], references: [id])
  events Event[]

  @@unique([regionId, slug])
  @@index([regionId])
  @@index([latitude, longitude])
  @@map("venues")
}

enum VenueType {
  BAR
  BREWERY
  CLUB
  THEATER
  CONCERT_HALL
  OUTDOOR
  CAFE
  RESTAURANT
  HOUSE_SHOW
  OTHER
}

// Artists and bands
model Artist {
  id            String   @id @default(cuid())
  name          String
  slug          String   @unique
  genres        String[] // array of genre slugs
  description   String?
  website       String?
  socialLinks   Json?    // { instagram, facebook, bandcamp, spotify, etc. }
  musicbrainzId String?
  isLocal       Boolean  @default(false)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Spotify integration
  spotifyId              String?              // Spotify artist ID
  spotifyName            String?              // Name as it appears on Spotify (may differ)
  spotifyMatchConfidence Float?               // 0-1 confidence score from name matching
  spotifyMatchStatus     SpotifyMatchStatus   @default(PENDING)
  spotifyPopularTracks   Json?                // [{trackId, name, uri, durationMs}]
  spotifyTracksUpdatedAt DateTime?            // When popular tracks were last fetched

  eventArtists          EventArtist[]
  spotifyPlaylistTracks SpotifyPlaylistTrack[]
  artistReviews         ArtistReview[]

  @@index([name])
  @@index([spotifyMatchStatus])
  @@map("artists")
}

// Events (shows, concerts)
model Event {
  id              String       @id @default(cuid())
  regionId        String
  venueId         String?
  title           String
  slug            String
  description     String?
  descriptionHtml String?      // Rich HTML description with images/videos/links
  imageUrl        String?      // Event/artist image from source
  startsAt        DateTime
  endsAt          DateTime?
  doorsAt         DateTime?
  coverCharge     String?      // "Free", "$10", "$10-15", "Donation"
  ageRestriction  AgeRestriction @default(ALL_AGES)
  ticketUrl       String?
  genres          String[]     // Genre/category tags from source (raw from scraper)

  // Classification fields (populated by AI classifier)
  isMusic           Boolean?       // true=music event, false=non-music, null=unclassified
  eventType         EventType?     // Classified event type
  canonicalGenres   String[]       // Normalized genre slugs from classifier
  summary           String?        // AI-generated concise summary for listing cards
  classifiedAt      DateTime?      // When classification was performed
  classificationConfidence Float?  // 0-1 confidence score from classifier

  sourceId        String?
  sourceUrl       String?
  sourceEventId   String?      // ID from the source for dedup
  confidenceScore Float        @default(1.0)
  reviewStatus    ReviewStatus @default(PENDING)
  reviewedBy      String?
  reviewedAt      DateTime?
  isCancelled     Boolean      @default(false)
  createdAt       DateTime     @default(now())
  updatedAt       DateTime     @updatedAt

  // Vector embedding for similarity search (managed via raw SQL)
  embedding       Unsupported("vector(1536)")?

  region       Region        @relation(fields: [regionId], references: [id])
  venue        Venue?        @relation(fields: [venueId], references: [id])
  source       Source?       @relation(fields: [sourceId], references: [id]) // Canonical source
  eventArtists EventArtist[]
  eventSources EventSource[] // All sources that found this event
  spotifyPlaylistTracks SpotifyPlaylistTrack[]

  @@unique([sourceId, sourceEventId])
  @@index([regionId, startsAt])
  @@index([venueId])
  @@index([reviewStatus])
  @@map("events")
}

enum AgeRestriction {
  ALL_AGES
  EIGHTEEN_PLUS
  TWENTY_ONE_PLUS
}

enum ReviewStatus {
  PENDING
  APPROVED
  REJECTED
  FLAGGED
}

enum EventType {
  MUSIC
  DJ
  OPEN_MIC
  COMEDY
  THEATER
  GAMES
  KARAOKE
  PRIVATE
  FILM
  SPOKEN_WORD
  DANCE
  MARKET
  WORKSHOP
  PARTY
  FITNESS
  DRAG
  OTHER
}

// Junction table for events and artists
model EventArtist {
  id        String    @id @default(cuid())
  eventId   String
  artistId  String
  order     Int       @default(1) // 1 = headliner, 2+ = support acts in billing order
  setTime   DateTime?

  event  Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  artist Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@unique([eventId, artistId])
  @@index([artistId])
  @@map("event_artists")
}

// Data sources (scrapers, APIs, manual)
model Source {
  id            String     @id @default(cuid())
  name          String     @unique
  slug          String     @unique
  type          SourceType
  category      SourceCategory @default(OTHER) // For dedup priority
  priority      Int        @default(50) // Lower = higher priority (venue=10, ticketing=20, band=30, etc.)
  trustScore    Float      @default(0.5) // 0-1
  website       String?
  parserVersion String?
  config        Json?      // scraper-specific config
  lastRunAt     DateTime?
  lastRunStatus String?
  nextRunAt     DateTime?
  runFrequency  Int        @default(86400) // seconds between runs
  consecutiveFailures Int  @default(0) // Track consecutive failures for notifications
  lastFailureAt DateTime?  // When the last failure occurred
  lastEventCount Int?       // Event count from last successful run (for failure detection)
  isActive      Boolean    @default(true)
  createdAt     DateTime   @default(now())
  updatedAt     DateTime   @updatedAt

  events       Event[]       // Events where this is the canonical source
  eventSources EventSource[] // All events this source has contributed to

  @@map("sources")
}

enum SourceType {
  SCRAPER
  API
  MANUAL
  IMPORT
}

enum SourceCategory {
  VENUE      // Official venue website - highest priority
  TICKETING  // Ticketing platforms
  PROMOTER   // Promoter/booking agency sites
  ARTIST     // Band/artist websites
  AGGREGATOR // Other aggregators
  SOCIAL     // Social media
  OTHER      // Unknown/other
}

// Track all sources that mention an event (for dedup and data enrichment)
model EventSource {
  id           String   @id @default(cuid())
  eventId      String
  sourceId     String
  sourceUrl    String?  // URL where this source found the event
  sourceEventId String? // ID from this source
  scrapedAt    DateTime @default(now())
  rawData      Json?    // Original scraped data for reference

  event  Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  source Source @relation(fields: [sourceId], references: [id])

  @@unique([eventId, sourceId])
  @@index([sourceId])
  @@map("event_sources")
}

// Genre taxonomy (hierarchical)
model Genre {
  id        String   @id @default(cuid())
  name      String   @unique
  slug      String   @unique
  parentId  String?
  sortOrder Int      @default(0)
  createdAt DateTime @default(now())

  parent   Genre?  @relation("GenreHierarchy", fields: [parentId], references: [id])
  children Genre[] @relation("GenreHierarchy")

  @@index([parentId])
  @@map("genres")
}

// Users (admin, liaisons)
model User {
  id            String   @id @default(cuid())
  email         String   @unique
  emailVerified Boolean  @default(false)
  displayName   String?
  role          UserRole @default(USER)
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  loginTokens LoginToken[]

  @@map("users")
}

enum UserRole {
  ADMIN
  MODERATOR
  USER
}

enum SpotifyMatchStatus {
  PENDING         // Not yet searched on Spotify
  AUTO_MATCHED    // High confidence automatic match (>0.9)
  NEEDS_REVIEW    // Low confidence match, needs human verification
  VERIFIED        // Manually confirmed correct match
  NO_MATCH        // Confirmed not on Spotify or should be skipped
}

// Login tokens for magic link authentication
model LoginToken {
  id        String   @id @default(cuid())
  token     String   @unique
  email     String
  userId    String?
  user      User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@index([email])
  @@index([token])
  @@map("login_tokens")
}

// AI Agent Sessions for scraper generation
model AgentSession {
  id              String            @id @default(cuid())
  url             String            // Target venue URL
  sessionType     AgentSessionType  // VENUE_INFO or EVENT_SCRAPER
  status          AgentSessionStatus @default(IN_PROGRESS)
  llmProvider     String            // anthropic, openai, google, deepseek
  llmModel        String            // model identifier
  currentIteration Int             @default(0)
  maxIterations   Int              @default(5)

  // Results
  venueData       Json?            // Scraped venue information
  eventData       Json?            // Array of scraped events
  generatedCode   String?          // Final working scraper code
  completenessScore Float?         // 0-1 score of field coverage

  // Metadata
  errorMessage    String?
  thinking        Json?            // Array of thinking steps for display
  createdAt       DateTime         @default(now())
  updatedAt       DateTime         @updatedAt
  completedAt     DateTime?

  // Relations
  venueId         String?          // Linked after approval
  sourceId        String?          // Linked after approval

  attempts        ScraperAttempt[]

  @@index([status])
  @@index([createdAt])
  @@map("agent_sessions")
}

enum AgentSessionType {
  VENUE_INFO      // First pass: scrape venue details
  EVENT_SCRAPER   // Second pass: generate event scraper
}

enum AgentSessionStatus {
  IN_PROGRESS
  SUCCESS
  FAILED
  APPROVED        // User approved and records created
  REJECTED        // User rejected
}

// Individual scraper generation attempts within a session
model ScraperAttempt {
  id              String        @id @default(cuid())
  sessionId       String
  attemptNumber   Int

  // Agent thinking
  reasoning       String?       // Why this approach
  planDescription String?       // What the agent plans to do

  // Input context - HTML the agent was working with
  // Structure: { listing: string, detailPages?: { url: string, html: string }[] }
  htmlSnapshots   Json?

  // Generated code
  generatedCode   String        // The scraper code generated
  codeHash        String?       // Hash to detect duplicate attempts

  // Execution results
  executionStatus String        // PENDING, RUNNING, SUCCESS, ERROR, TIMEOUT
  executionError  String?
  executionTime   Int?          // milliseconds
  scrapedData     Json?         // Results from execution

  // Evaluation
  fieldsFound     String[]      // Which fields were successfully extracted
  fieldsMissing   String[]      // Which required fields are missing
  completenessScore Float?      // 0-1 score

  createdAt       DateTime      @default(now())
  completedAt     DateTime?

  session         AgentSession  @relation(fields: [sessionId], references: [id], onDelete: Cascade)

  @@unique([sessionId, attemptNumber])
  @@index([sessionId])
  @@map("scraper_attempts")
}

// LLM Provider Configuration
model LLMConfig {
  id              String   @id @default(cuid())
  provider        String   @unique // anthropic, openai, google, deepseek
  apiKey          String   // Encrypted
  isEnabled       Boolean  @default(true)
  models          Json     // Available models for this provider
  defaultModel    String?  // Default model to use
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  @@map("llm_configs")
}

// Spotify playlist sync configuration
model SpotifyPlaylist {
  id           String    @id @default(cuid())
  playlistId   String    @unique  // Spotify playlist ID
  name         String              // Display name for admin UI
  description  String?             // Playlist description
  regionId     String?             // Optional: limit to specific region
  daysAhead    Int       @default(30)  // How many days ahead to include events
  syncEnabled  Boolean   @default(true)
  lastSyncedAt DateTime?
  lastSyncError String?            // Error message from last failed sync
  createdAt    DateTime  @default(now())
  updatedAt    DateTime  @updatedAt

  @@map("spotify_playlists")
}

// Track which tracks are currently in each playlist (for efficient diffing)
model SpotifyPlaylistTrack {
  id           String   @id @default(cuid())
  playlistId   String   // References SpotifyPlaylist.playlistId
  trackUri     String   // Spotify track URI
  artistId     String   // Our artist ID
  eventId      String   // The event this track is for
  addedAt      DateTime @default(now())

  event  Event  @relation(fields: [eventId], references: [id], onDelete: Cascade)
  artist Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)

  @@unique([playlistId, trackUri])
  @@index([playlistId])
  @@index([eventId])
  @@index([artistId])
  @@map("spotify_playlist_tracks")
}

// Spotify OAuth credentials (singleton - only one row)
model SpotifyAuth {
  id           String   @id @default("spotify_auth") // Fixed ID for singleton
  accessToken  String   // Current access token
  refreshToken String   // Refresh token for getting new access tokens
  expiresAt    DateTime // When the access token expires
  scope        String   // Granted scopes
  userId       String?  // Spotify user ID of the authorized account
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  @@map("spotify_auth")
}

// Review sources (local music blogs, newsletters)
model ReviewSource {
  id            String    @id @default(cuid())
  name          String    @unique // "Freakscene"
  slug          String    @unique // "freakscene"
  feedUrl       String    // Archive/feed URL to scrape
  type          String    @default("buttondown") // buttondown, rss, etc.
  lastFetchedAt DateTime?
  isActive      Boolean   @default(true)
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  reviews Review[]

  @@map("review_sources")
}

// Reviews/articles from local music writers
model Review {
  id          String    @id @default(cuid())
  sourceId    String
  url         String    @unique // Canonical URL of the review
  title       String
  excerpt     String?   // First paragraph or so for display
  publishedAt DateTime?
  fetchedAt   DateTime  @default(now())

  source        ReviewSource   @relation(fields: [sourceId], references: [id])
  artistReviews ArtistReview[]

  @@index([sourceId])
  @@index([publishedAt])
  @@map("reviews")
}

// Junction table linking reviews to featured artists
model ArtistReview {
  id        String   @id @default(cuid())
  artistId  String
  reviewId  String
  createdAt DateTime @default(now())

  artist Artist @relation(fields: [artistId], references: [id], onDelete: Cascade)
  review Review @relation(fields: [reviewId], references: [id], onDelete: Cascade)

  @@unique([artistId, reviewId])
  @@index([reviewId])
  @@map("artist_reviews")
}

// Chat logs for AI assistant interactions
model ChatLog {
  id                 String   @id @default(cuid())
  sessionId          String   // Group conversations together
  timestamp          DateTime @default(now())
  ipAddress          String?  // For rate limiting by IP

  // Request
  userMessage        String
  conversationLength Int      // How many turns in

  // LLM Usage (cost tracking)
  inputTokens        Int
  outputTokens       Int
  estimatedCostUsd   Float    // Calculated from token counts
  llmCallsCount      Int      // 1 = direct answer, 2+ = tool use
  model              String

  // Tools
  toolsUsed          String[] // ["search_events", "get_venue_events"]
  toolInputs         Json?    // For debugging

  // Response
  responseText       String
  latencyMs          Int

  // Quality signals
  userRating         Int?     // 1-5 or thumbs up/down

  @@index([sessionId])
  @@index([timestamp])
  @@index([ipAddress, timestamp]) // For IP-based rate limiting
  @@map("chat_logs")
}
