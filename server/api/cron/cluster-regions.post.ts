/**
 * Cron endpoint for updating region clusters
 * POST /api/cron/cluster-regions
 *
 * Runs DBSCAN clustering on venues and creates/updates regions
 * Authentication: Requires CRON_SECRET token via query param or header
 *
 * Add to server crontab:
 *   Run weekly on Sundays at 3am: 0 3 * * 0 curl -sX POST "http://localhost:3000/api/cron/cluster-regions?token=$CRON_SECRET"
 */

import prisma from '../../utils/prisma'
import { verifyCronAuth } from '../../utils/cron-auth'
import { clusterVenues } from '../../services/clustering'
import { sendSlackNotification } from '../../services/notifications'

export default defineEventHandler(async (event) => {
  // Verify cron authentication
  verifyCronAuth(event)

  const start = Date.now()
  console.log('[Cron] Starting region clustering...')

  try {
    // Run clustering algorithm
    const { regions, unassigned, stats } = await clusterVenues(prisma)

    // Track changes for reporting
    const changes: string[] = []

    // Get existing auto-generated regions
    const existingRegions = await prisma.region.findMany({
      where: { isAutoGenerated: true },
      include: { venues: { select: { id: true } } },
    })
    const existingBySlug = new Map(existingRegions.map(r => [r.slug, r]))

    // Process each discovered cluster
    for (const cluster of regions) {
      const existing = existingBySlug.get(cluster.slug)
      const venueIds = cluster.venues.map(v => v.id)

      if (existing) {
        // Check if the region has changed significantly
        const existingVenueIds = new Set(existing.venues.map(v => v.id))
        const newVenues = venueIds.filter(id => !existingVenueIds.has(id))
        const removedVenues = [...existingVenueIds].filter(id => !venueIds.includes(id))

        if (newVenues.length > 0 || removedVenues.length > 0 ||
            existing.centroidLat !== cluster.centroid.lat ||
            existing.centroidLng !== cluster.centroid.lng) {
          // Update existing region
          await prisma.region.update({
            where: { id: existing.id },
            data: {
              centroidLat: cluster.centroid.lat,
              centroidLng: cluster.centroid.lng,
              updatedAt: new Date(),
            },
          })

          // Update venue assignments
          await prisma.venue.updateMany({
            where: { id: { in: venueIds } },
            data: { regionId: existing.id },
          })

          changes.push(`Updated "${cluster.name}": +${newVenues.length}/-${removedVenues.length} venues`)
        }

        existingBySlug.delete(cluster.slug)
      } else {
        // Create new region
        const newRegion = await prisma.region.create({
          data: {
            name: cluster.name,
            slug: cluster.slug,
            centroidLat: cluster.centroid.lat,
            centroidLng: cluster.centroid.lng,
            isAutoGenerated: true,
            isActive: true,
          },
        })

        // Assign venues to new region
        await prisma.venue.updateMany({
          where: { id: { in: venueIds } },
          data: { regionId: newRegion.id },
        })

        changes.push(`Created "${cluster.name}" with ${venueIds.length} venues`)
      }
    }

    // Handle regions that no longer have enough venues (don't delete, just mark inactive)
    for (const oldRegion of existingBySlug.values()) {
      await prisma.region.update({
        where: { id: oldRegion.id },
        data: { isActive: false },
      })
      changes.push(`Deactivated "${oldRegion.name}" (no longer enough venues)`)
    }

    const duration = Date.now() - start

    // Send notification if there were changes
    if (changes.length > 0) {
      await sendSlackNotification(
        `ðŸ—ºï¸ Region Clustering Complete`,
        [
          {
            type: 'section',
            text: {
              type: 'mrkdwn',
              text: [
                `ðŸ—ºï¸ *Region Clustering Complete*`,
                '',
                `*Stats:*`,
                `â€¢ Total venues: ${stats.totalVenues}`,
                `â€¢ Clustered: ${stats.clusteredVenues}`,
                `â€¢ Regions: ${stats.regionCount}`,
                `â€¢ Unassigned: ${unassigned.length}`,
                '',
                `*Changes:*`,
                ...changes.map(c => `â€¢ ${c}`),
              ].join('\n'),
            },
          },
        ]
      )
    }

    console.log(`[Cron] Region clustering complete in ${duration}ms`)

    return {
      success: true,
      duration,
      stats,
      changes,
      unassignedVenues: unassigned.map(v => ({ name: v.name, city: v.city, state: v.state })),
    }
  } catch (error) {
    console.error('[Cron] Region clustering failed:', error)

    await sendSlackNotification(
      `ðŸš¨ Region Clustering Failed`,
      [
        {
          type: 'section',
          text: {
            type: 'mrkdwn',
            text: `ðŸš¨ *Region Clustering Failed*\n\nError: ${error instanceof Error ? error.message : 'Unknown error'}`,
          },
        },
      ]
    )

    throw createError({
      statusCode: 500,
      statusMessage: error instanceof Error ? error.message : 'Clustering failed',
    })
  }
})
